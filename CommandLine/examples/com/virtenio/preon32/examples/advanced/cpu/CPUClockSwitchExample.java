/*
 * Copyright (c) 2011., Virtenio GmbH
 * All rights reserved.
 *
 * Commercial software license.
 * Only for test and evaluation purposes.
 * Use in commercial products prohibited.
 * No distribution without permission by Virtenio.
 * Ask Virtenio for other type of license at info@virtenio.de
 *
 * Kommerzielle Softwarelizenz.
 * Nur zum Test und Evaluierung zu verwenden.
 * Der Einsatz in kommerziellen Produkten ist verboten.
 * Ein Vertrieb oder eine Veröffentlichung in jeglicher Form ist nicht ohne Zustimmung von Virtenio erlaubt.
 * Für andere Formen der Lizenz nehmen Sie bitte Kontakt mit info@virtenio.de auf.
 */

package com.virtenio.preon32.examples.advanced.cpu;

import com.virtenio.driver.cpu.CPU;
import com.virtenio.driver.cpu.CPUException;
import com.virtenio.driver.cpu.NativeCPU;
import com.virtenio.driver.device.at86rf231.AT86RF231;
import com.virtenio.driver.spi.SPI;
import com.virtenio.driver.usart.NativeUSART;
import com.virtenio.driver.usart.USART;
import com.virtenio.driver.usart.USARTParams;
import com.virtenio.preon32.cpu.CPUConstants;
import com.virtenio.preon32.cpu.CPUHelper;
import com.virtenio.preon32.node.Node;
import com.virtenio.vm.Time;

/**
 * Example how to use CPU clock frequency switching feature. There are 5 CPU
 * clock profiles and 3 CPU clock modes which can be switched.
 * <p>
 * Clock mode HSI: The clock signal is generated by an internal oscillator <br>
 * Clock mode HSE: The clock signal is generated by an external oscillator <br>
 * Clock mode EXT: The clock signal is provided by an external clock
 * <p>
 * Each of these 3 modes have 5 clock profiles. The frequencies of the clock
 * profiles are defines as <code>P1 <= P2 <= P3 <= P4 <= P5</code>
 * <p>
 * Be careful when changing clock frequency. All native hardware devices must be
 * closed before clock profile switch and reopened afterwards to work correctly.
 * If you do not close and reopen native hardware the devices can have wrong
 * prescalers which results in wrong frequencies.
 */
public class CPUClockSwitchExample {

	/**
	 * Switch the clock to a given mode and a given profile. Opened hardware
	 * devices must be closed before or reopened after.
	 */
	public static void switchClock(int mode, int profile) {
		System.out.println("Switch clock to mode " + mode + " and profile id " + profile);

		// flush stdout to empty output buffer
		System.out.flush();

		// error flag
		int error = 0;

		// switch the clock
		try {
			CPUHelper.setClock(mode, profile);
		} catch (CPUException e) {
			// we can't print something here..
			error = e.getErrorCode();
		}

		// Re-open stdout
		USART stdOut = NativeUSART.getInstance(0);
		try {
			stdOut.close();
			stdOut.open(new USARTParams(115200, USART.DATA_BITS_8, USART.STOP_BITS_1,
					USART.PARITY_NONE));
		} catch (Exception e) {
			e.printStackTrace();
		}

		if (error != 0) {
			System.out.println("Error setting clock: " + error);
		}
	}

	/**
	 * Setup the external AT86RF231 transceiver to output a master clock signal
	 * which is used to clock the controller. The master clock frequency must be
	 * 1 MHz.
	 */
	public static void setupTransceiverClock() {
		System.out.println("Setup master clock of transceiver");

		// configure CLKM of transceiver to 1 MHz
		try {
			AT86RF231 transceiver = Node.getInstance().getTransceiver();
			transceiver.open();
			transceiver.setMasterClockFrequency(AT86RF231.CLKM_1MHz);

			// Do not close the transceiver driver, will stop clock output
			// transceiver.close();

			// Do not enter sleep mode of transceiver if running in EXT clock
			// mode. Clock signal is not working in sleep mode. Change to HSI
			// mode before entering sleep mode of the transceiver.

			// Close or reopen the SPI instance to which the transceiver is
			// connected.
			SPI spi = transceiver.getSPI();
			spi.close();
			spi.open(AT86RF231.SPI_MODE, AT86RF231.SPI_BIT_ORDER, AT86RF231.SPI_MAX_SPEED);
		} catch (Exception e1) {
			e1.printStackTrace();
		}
	}

	/**
	 * Simple loop cycles per second measurement
	 */
	public static int measureCyclesPerSec() {
		int counter = 0;
		long start = Time.millis();
		while (Time.millis() - start < 1000) {
			counter++;
		}
		return counter;
	}

	/**
	 * Print current clock frequency
	 */
	public static void printCurrentSpeed() throws CPUException {
		CPU cpu = NativeCPU.getInstance();
		long frequency = cpu.get(CPUConstants.K_CLOCK_FREQUENCY);
		System.out.println("Current CPU freuency: " + (frequency / 1000 / 1000) + " MHz");
	}

	/**
	 * Run a loop test to measure performance
	 */
	public static void runTest() {
		// ensure that stdout has nothing to do
		System.out.flush();

		try {
			// print the clock frequency
			printCurrentSpeed();

			// measure cycles per second
			System.out.println("Loops per sec: " + measureCyclesPerSec());
		} catch (CPUException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Switches to the mode and profile which has maximum CPU speed
	 */
	public static void setMaxSpeed() throws CPUException {
		setupTransceiverClock();
		switchClock(CPUConstants.V_CLOCK_MODE_EXT, CPUConstants.V_CLOCK_PROFILE_5);
		printCurrentSpeed();
	}

	public static void main(String[] args) throws Exception {
		System.out.println("TEST CPU Clock");

		// run a test
		runTest();

		System.out.println("Test HSI clock mode");

		// switch HSI profiles in ascending order and run a test
		for (int profile = CPUConstants.V_CLOCK_PROFILE_1; profile <= CPUConstants.V_CLOCK_PROFILE_5; profile++) {
			switchClock(CPUConstants.V_CLOCK_MODE_HSI, profile);
			runTest();
		}

		System.out.println("Test EXT clock mode");

		// setup the transceiver master clock to be used as external clock
		// signal
		setupTransceiverClock();

		// switch EXT profiles in ascending order and run a test
		for (int profile = CPUConstants.V_CLOCK_PROFILE_1; profile <= CPUConstants.V_CLOCK_PROFILE_5; profile++) {
			switchClock(CPUConstants.V_CLOCK_MODE_EXT, profile);
			runTest();
		}
		
		System.out.flush();
	}
}
